#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#include "lexer.h"
#include "../parser/parser.h"

#define STRING_BUFFER_LENGTH  3 /**< Maximum length of an operator string. */

/** Enum of possible machine states.
 *
 *  This enum lists all the possible states for the state machine. Aside from
 *  the usual start-, error-, and accept states we have separate states for
 *  distinguishing all the possible categories of inputs. Those are strings for
 *  functions and special constants (like _sin_ or _pi_), integer numbers,
 *  decimal numbers and special symbol characters like parentheses or the plus
 *  sign.
 *
 *  At this stage we are not concerned with their meaning, we only want to
 *  decide what the user's input is made of. We well then later decide if that
 *  input is a valid operator, and then finally of those operators constitute a
 *  valid syntax.
 *
 *  The last enum item is not an actual state, but it tells us how many states
 *  the state machine actually has.
 */
enum lexer_state{
	ST_START         , /**< Return after encountering whitespace or symbol. */
	ST_ERROR         , /**< State after encountering a format error.        */
	ST_ACCEPT        , /**< State for successful parsing.                   */
	ST_LETTER        , /**< Concatenating letters into words for functions. */
	ST_NUMBER        , /**< Gathering digits into a complete number.        */
	ST_DECIMAL_POINT , /**< Right after reading a decimal point.            */
	ST_DECIMAL_NUM   , /**< After encountering a decimal point.             */
	ST_SYMBOL        , /**< State for non-alphanumeric characters.          */
	LEXER_STATES       /**< Useful constant, not an actual state.           */
};

/** Enum of possible input character types.
 *
 *  Every input character can be roughly categorized into one of the following
 *  character classes. We use this information to decide what state to switch
 *  the machine to next.
 */
enum char_class {
	LETTER  ,    /**< Class for letter a - z and A - Z.      */
	DIGIT   ,    /**< Class for digits 0 - 9.                */
	DECIMAL ,    /**< Class for the *full stop* character.   */
	SYMBOL  ,    /**< Class for non-alphanumeric characters. */
	SPACE   ,    /**< Class for whitespace characters.       */
	UNKNOWN ,    /**< Class for unknown characters.          */

	CHAR_CLASSES /**< Useful constant, not an actual token.  */
};

struct lexer {
	/** Parser to parse the nodes generated by this lexer. */
	struct parser *parser;

	/** Immutable pointer to the first character of the string to lex.
	 *
	 *  This is useful if we want to know where the read head is in relation to the
	 *  starting position, like when we want to know which character exactly the
	 *  lexer choked on. In that case we simply print `read_head -
	 *  string_to_parse`.
	 */
	const char *string_to_parse;

	/** Pointer to a char within the string to parse.
	 *
	 *  This pointer will be incremented each time we have successfully read a
	 *  character until we reach the end end of the string. This is analogous to
	 *  the reading head of a read-only Turing machine.
	 */
	const char *read_head;

	/** The current state of the state machine.
	 *
	 *  This variable keeps track of the current state of the state machine. It
	 *  only tracks the state we are currently in, not the state we came from.
	 */
	enum lexer_state current_state;

	/** The previous state of the state machine.
	 *
	 *  This variable keeps track of the previous state of the state machine. It is
	 *  the complement of #current_state.
	 */
	enum lexer_state previous_state;

	/** Number buffer for collecting numbers.
	 *
	 *  When we read a digit we cannot be sure that that digit is the entire
	 *  number. There could be other digits and even a decimal point following,
	 *  which would all form one larger number together. This variable is where we
	 *  process all those digits into one number until we are done. Then we pass
	 *  the result on.
	 */
	double number_buffer;

	/** Keeps track of the current power of ten.
	 *
	 *  Each time we read a digit the power of ten of that digit in the resulting
	 *  number increases. For integer numbers we can simply multiply the current
	 *  number buffer by ten and add the digit, so we don't need to keep track of
	 *  the power. However, for decimal numbers do need to know the current power.
	 *  The formula is:
	 *  @code
	 *      number_buffer += char_to_double(read_head) * power;
	 *      power *= 0.1;
	 *  @endcode
	 */
	double power;

	/** String buffer for collecting characters into a string.
	 *
	 *  Characters read by the machine are stored in this buffer until a non-letter
	 *  character is read. The buffer is initially filled with NUL characters until
	 *  it's needed, and after we are done we fill it with NUL characters again.
	 */
	char string_buf[STRING_BUFFER_LENGTH + 1]; // three characters + 1 for \0

	/** Pointer moving through the string buffer.
	 *
	 *  The string buffer stores the string, but this pointer tells us where in the
	 *  string we currently are. Each time we store a character int he buffer we
	 *  increment this pointer. Once done we set it back to the beginning of the
	 *  buffer.
	 */
	char *string_ptr;

	/** Character representing a single symbol.
	 *
	 *  If the parsing machine reads a symbol, which is a character that's neither
	 *  a digit nor a letter, but still a known character, it is a symbol. We store
	 *  it in this variable to retrieve if later.
	 */
	char symb;

	/** The previous node that was passed to the syntax tree builder.
	 *
	 *  This variable is used to differentiate the minus sign between the binary
	 *  subtraction and the unary negation. If the previous node is nothing or a
	 *  left parenthesis we have a negation, otherwise a subtraction.
	 */
	struct syntax_node *previous_node;
};

/** Struct for the machine's transition information.
 *
 *  The struct tell us what action to perform when the machine is about the
 *  switch to the specified state. This is struct is useless if we don't know
 *  which state the machine is currently it. For instance, switching to the
 *  letter state after a number state will have a different effect than
 *  switching to the letter state while being already in the letter state.
 *
 *  This means we need some way to map the current state to a transition
 *  instruction; this is done in the #lexer_transition_table table.
 */
struct transition_instruction {
	enum lexer_state next_state;
	void (*action)(Lexer *l);
};


/*--[ control instructions for the machine ]----------------------------------*/

/** Lex the next character from the input string.
 *  
 *  As long as there are characters on the input string to read this function
 *  will move to the next one and process it. If the end of the string has been
 *  reached the function will transition the machine into the accepting state,
 *  thus prompting the machine to terminate.
 */
static void lex_next_char(Lexer *l);

/** Transitions the lexing machine's state based on the current state.
 *  
 *  The current state becomes the new previous state and the next state is
 *  chosen from the table based on the current state. Then the appropriate
 *  action is performed.
 *
 *  @sa previous_state, current_state, lexer_transition_table
 *
 *  @param to  Character class for the next state.
 */
static void transition_state(Lexer *l, enum char_class to);

/** Throws a lexical analysis error.
 *
 *  If the input string contains unknown input this function will be called. It
 *  does not matter if the input is valid syntax or not, the only thing that
 *  matters is whether the represents valid mathematical notation. The function
 *  prints an error to *stderr* and exits the program.
 */
static void throw_format_error();

/** Creates a character class item based on the type of character read.
 *  
 *  This function takes in a character and decides what type of character it
 *  is, i.e. a letter, a digit, a symbol, a decimal point or a whitespace.
 *  Depending on that it returns the appropriate class item.
 * 
 *  @param character  The character being read.
 *
 *  @returns  Character class item that represents the type of the input 
 *            character.
 */
static enum char_class digest_input_char(Lexer *l, const char *character);

/** Passes a syntax node over to the parser.
 *
 *  Certain lexer actions generate syntax nodes, these nodes must then be
 *  passed to the parser where the shunting-yard algorithm will construct the
 *  tree. This node also becomes the new previous node, which is sometimes used
 *  for reference.
 *
 *  @param node  The node to be passed to the parser.
 *
 *  @sa previous_node, syntax_tree_builder_parse_node
 */
static void pass_syntax_node(Lexer *l, struct syntax_node *node);

/** Initializes the number buffer.
 *
 *  Sets the number buffer to 0.0 and the power counter to 0.1, overwriting
 *  previous values.
 *
 *  @sa number_buffer, power
 */
static void init_num_buf(Lexer *l);

/** Initializes the string buffer.
 *
 *  Sets the contents of the string buffer all to `\0` and the string pointer
 *  to the head of the string buffer. Then it appends the next char from the
 *  input string.
 *
 *  @sa string_buf, string_ptr, append_char
 */
static void init_str_buf(Lexer *l);

/*--[ Actions ]---------------------------------------------------------------*/

/** Lexer action that does nothing.
 *
 *  This action is only used when transitioning into the error state or the
 *  accepting state.
 */
static void no_act(Lexer *l);

/** Lexer action that Initialises the power counter for decimal numbers.
 *
 *  This action sets the power counter to 0.1 and is called when the number
 *  parsed is a decimal number.
 *
 *  @sa  power
 */
static void init_decimal(Lexer *l);

/** Lexer action that appends a digit to the number buffer.
 *
 *  This action multiplies the number buffer by 10 and adds the numeric value
 *  of the current character (a digit) to it. This has the same effect as
 *  appending a digit to an existing number.
 *
 *  @sa number_buffer
 */
static void append_digit(Lexer *l);

/** Lexer action that appends a decimal digit to the number buffer.
 *
 *  This action adds the numeric value of the current character multiplied by
 *  the current number power to the number buffer. Then it multiplies the power
 *  counter by 0.1 for the next digit. If the end of the buffer has already
 *  been reached a format error is thrown.
 *
 *  @sa string_buf, string_ptr
 */
static void append_decimal(Lexer *l);

/** Lexer action that appends a character to the string buffer.
 *
 *  This action appends the current character to the current position in the
 *  string buffer. It does so by inserting the character at the position the
 *  string pointer is pointing at and then incrementing the pointer.
 *
 *  @sa number_buffer, power
 */
static void append_char(Lexer *l);

/** Lexer action that passes a number node.
 *
 *  This action constructs a number node out of the number buffer, passes it to
 *  the syntax tree builder and then resets the number buffer.
 *
 *  @sa number_buffer, pass_syntax_node, init_num_buf
 */
static void pass_number_node(Lexer *l);

/** Lexer action that passes a function node.
 *
 *  This action constructs a function node out of the string buffer, passes it
 *  to the syntax tree builder and then resets the string buffer and string
 *  pointer.
 *
 *  @sa string_buf, string_ptr, pass_syntax_node
 */
static void pass_function_node(Lexer *l);

/** Lexer action that passes a symbol node.
 *
 *  This action constructs a symbol node out of the current character and
 *  passes it to the syntax tree builder.
 *
 *  @sa char_to_operator, pass_syntax_node
 */
static void pass_symbol_node(Lexer *l);

/** Array of transition instructions, structured like a table.
 *
 *  The first coordinate corresponds to the current state, the second one to
 *  the type of symbol that's read.
 */
static struct transition_instruction lexer_transition_table[LEXER_STATES][CHAR_CLASSES] = {
	[ST_START] = {
		[ LETTER  ] = { .next_state = ST_LETTER        , .action = append_char        },
		[ DIGIT   ] = { .next_state = ST_NUMBER        , .action = append_digit       },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_SYMBOL        , .action = pass_symbol_node   },
		[ SPACE   ] = { .next_state = ST_START         , .action = no_act             },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act             }
	},
	[ST_ERROR ] = {
		[ LETTER  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DIGIT   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SPACE   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act             },
	},
	[ST_ACCEPT] = {
		[ LETTER  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DIGIT   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SPACE   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act             },
	},
	[ST_LETTER] = {
		[ LETTER  ] = { .next_state = ST_LETTER        , .action = append_char        },
		[ DIGIT   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_SYMBOL        , .action = pass_function_node },
		[ SPACE   ] = { .next_state = ST_START         , .action = pass_function_node },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act             },
	},
	[ST_NUMBER] = {
		[ LETTER  ] = { .next_state = ST_LETTER        , .action = pass_number_node   },
		[ DIGIT   ] = { .next_state = ST_NUMBER        , .action = append_digit       },
		[ DECIMAL ] = { .next_state = ST_DECIMAL_POINT , .action = init_decimal       },
		[ SYMBOL  ] = { .next_state = ST_SYMBOL        , .action = pass_number_node   },
		[ SPACE   ] = { .next_state = ST_START         , .action = pass_number_node   },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act}
	},
	[ST_DECIMAL_POINT] = {
		[ LETTER  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ DIGIT   ] = { .next_state = ST_DECIMAL_NUM   , .action = append_decimal     },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SPACE   ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act}
	},
	[ST_DECIMAL_NUM] = {
		[ LETTER  ] = { .next_state = ST_LETTER        , .action = pass_number_node   },
		[ DIGIT   ] = { .next_state = ST_DECIMAL_NUM   , .action = append_decimal     },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_SYMBOL        , .action = pass_number_node   },
		[ SPACE   ] = { .next_state = ST_START         , .action = pass_number_node   },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act}
	},
	[ST_SYMBOL] = {
		[ LETTER  ] = { .next_state = ST_LETTER        , .action = append_char        },
		[ DIGIT   ] = { .next_state = ST_NUMBER        , .action = append_digit       },
		[ DECIMAL ] = { .next_state = ST_ERROR         , .action = no_act             },
		[ SYMBOL  ] = { .next_state = ST_SYMBOL        , .action = pass_symbol_node   },
		[ SPACE   ] = { .next_state = ST_START         , .action = no_act             },
		[ UNKNOWN ] = { .next_state = ST_ERROR         , .action = no_act}
	},
};

/** Helper function that converts a char to its double value. The result is
 *  undefined for non-numeric characters.
 *
 *  @param c  Pointer to a numeric character
 *
 *  @return  Double value of a numeric character (e.g. 3.0 for '3'), undefined
 *           for non-numeric characters.
 */
static double char_to_double(const char *c);

struct lexer *init_lexer(const char *string) {
	Lexer *l = malloc(sizeof(Lexer));

	l->parser = parser_init();

	l->previous_node = NULL;
	l->read_head = l->string_to_parse = string;
	
	l->current_state = lexer_transition_table[ST_START][digest_input_char(l, l->read_head)].next_state;
	l->previous_state = ST_START;
	
	l->string_buf[STRING_BUFFER_LENGTH] = '\0';
	l->string_ptr = &(l->string_buf[0]); // set the buffer pointer to the buffer's head
	
	// set up the number buffer for collecting digits into numbers
	init_num_buf(l);
	
	lexer_transition_table[l->current_state][digest_input_char(l, l->read_head)].action(l);
	++(l->read_head);

	return l;
}

void run_lexer(Lexer *l) {
	while (l->current_state != ST_ACCEPT && l->current_state != ST_ERROR) {
		lex_next_char(l);
	}
}

struct syntax_node *destroy_lexer(Lexer *l) {
	/* The resulting syntax tree. */
	struct syntax_node *result = NULL;

	l->previous_node = NULL;
	l->string_ptr    = NULL;

	// fill the string buffer with NUL
	for (int i = 0; i <= STRING_BUFFER_LENGTH; i++) {
		l->string_buf[i] = '\0';
	}

	l->number_buffer = 0.0;
	l->power = 0.1;
	if (l->current_state == ST_ERROR) {
		throw_format_error();
	} else {
		l->current_state = ST_START;
		result =  parser_finish(l->parser);

	}
	free(l->parser);
	l->parser = NULL;
	free(l);

	return result;
}

void lex_next_char(Lexer *l){
	if (*(l->read_head) == '\0') { // reached the end of the string without problems
		// perform the action of the previous state before shutting down the machine
		lexer_transition_table[l->current_state][SPACE].action(l);
		l->current_state = ST_ACCEPT;
		return;
	}
	transition_state(l, digest_input_char(l, l->read_head));
	l->read_head++;
}

static void transition_state(Lexer *l, enum char_class to) {
	l->previous_state = l->current_state;
	l->current_state = lexer_transition_table[l->current_state][to].next_state;
	lexer_transition_table[l->previous_state][to].action(l);
}

void init_num_buf(Lexer *l) {
	l->number_buffer = 0.0;
	l->power = 0.1;
}

void init_str_buf(Lexer *l) {
	// reset the string buffer
	for (int i = 0; i < STRING_BUFFER_LENGTH; ++i) {
		(l->string_buf)[i] = '\0';
	}
	l->string_ptr = &(l->string_buf[0]);
	append_char(l);
}

void no_act(Lexer *l) {}

void init_decimal(Lexer *l) {
	l->power = 0.1;
}

void append_digit(Lexer *l) {
	l->number_buffer = l->number_buffer * 10.0 + char_to_double(l->read_head);
}

void append_decimal(Lexer *l) {
	l->number_buffer += char_to_double(l->read_head) * l->power;
	l->power *= 0.1;
}

void append_char(Lexer *l) {
	// we have reached the end of the string buffer, reading more is an error
	if (l->string_ptr - &(l->string_buf[0]) >= STRING_BUFFER_LENGTH) {
		l->current_state = ST_ERROR;
		fprintf(stderr, "Error while parsing: string buffer full, currently %s, trying to append %c.", l->string_buf, *l->string_ptr);
	} else {
		*l->string_ptr = *l->read_head;
		++l->string_ptr;
	}
}

void pass_number_node(Lexer *l) {
	// pass the number to the tree-builder
	pass_syntax_node(l, syntax_node_construct(OP_NUMBER, l->number_buffer));
	l->number_buffer = 0.0;
	// if the number is followed by a letter...
	if (l->current_state == ST_LETTER) {
		// ... also pass a TIMES
		pass_syntax_node(l, syntax_node_construct(OP_TIMES, 0));
		init_str_buf(l);
	}
	init_num_buf(l);
	if (l->current_state == ST_SYMBOL) {
		pass_symbol_node(l);
	}
}

void pass_function_node(Lexer *l) {
	// terminate the string buffer with \0
	*l->string_ptr = '\0';
	enum operator_type operator = string_to_operator(l->string_buf);
	// pick the right function operator and pass it
	pass_syntax_node(l, syntax_node_construct(operator, 0));
	
	l->string_ptr = &l->string_buf[0]; // set the pointer back to the beginning of the string
	for (int i = 0; i < STRING_BUFFER_LENGTH; ++i) {// clean up string buffer
		l->string_buf[i] = '\0';
	}
	if (l->current_state == ST_SYMBOL) {
		pass_symbol_node(l);
	}
}

void pass_symbol_node(Lexer *l) {
	//pick the symbol and pass it
	enum operator_type operator = char_to_operator(&l->symb);
	int previous = l->previous_node == NULL ? -1 : l->previous_node->operator_value;

	if (operator == OP_UNKNOWN) {
		printf("Format error: unknown symbol %c.\n", l->symb);
		exit(1);
	}

	// substitute OP_MINUS with OP_NEGATE if necessary; a unary minus is
	// allowed either at the start of the expression or following an opening
	// brace.
	if (operator == OP_MINUS && (previous == -1 || previous == OP_LEFT_BRACE)) {
		pass_syntax_node(l, syntax_node_construct(OP_NEGATE, 0));
		return;
	}
	pass_syntax_node(l, syntax_node_construct(operator, 0));
}

void pass_syntax_node(Lexer *l, struct syntax_node *node) {
	enum operator_type operator = node->operator_value;

	// implicit OP_TIMES
	if (l->previous_node) {
		// preceding an opening brace after a nullary token
		if (operator == OP_LEFT_BRACE && l->previous_node->operator_value != OP_LEFT_BRACE && l->previous_node->arity == 0) {
			pass_syntax_node(l, syntax_node_construct(OP_TIMES, 0));
		}

		// succeeding a closing brace before a unary or nullary token
		if (l->previous_node->operator_value == OP_RIGHT_BRACE && node->arity < 2) {
			pass_syntax_node(l, syntax_node_construct(OP_TIMES, 0));
		}
		/* This is not quite right, even an n-ary token following a closing
 		 * brace can prompt and implicit *times*, as long as it's a prefix
 		 * operator, like a function. */
	}
	l->previous_node = node;
	parser_parse_node(l->parser, node);
}

void throw_format_error(){
	fprintf(stderr, "Formating error while parsing function.");
	exit(1);
}

enum char_class digest_input_char(Lexer *l, const char *character) {
	if (isalpha(*character)) {
		return LETTER;
	}
	if (isdigit(*character)) {
		return DIGIT;
	}
	if (*character == '+' || *character == '-' || *character == '*' || *character == '/' || *character == '^'
		|| *character == '(' || *character == ')'
		|| *character == '[' || *character == ']') {
		l->symb = *character;
		return SYMBOL ;
	}
	if (*character == '.') {
		return DECIMAL;
	}
	if (isspace(*character)) {
		return SPACE;
	}
	
	fprintf(stderr, "Format error: character \'%c\' from the input formula does not"
			"correspond to any known symbol or function. Error noticed at position %li .\n",
			*character, l->read_head - l->string_to_parse);
	exit(1);
}

double char_to_double(const char *c) {
	return (double) (*c - '0');
}

