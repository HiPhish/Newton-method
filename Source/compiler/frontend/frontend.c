#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <assert.h>

#include "frontend.h"

/*===[ DECLARATIONS ]=========================================================*/

/*---[ Constants and enumerations ]-------------------------------------------*/
#define STRING_BUFFER_LENGTH  3 /**< Maximum length of an operator string. */

#define STACK_SIZE_DEFAULT    7 /**< Default starting size for the operator-
and operand stack. */

/** Enum of possible machine states.
 *
 *  This enum lists all the possible states for the state machine. Aside from
 *  the usual start-, error-, and accept states we have separate states for
 *  distinguishing all the possible categories of inputs. Those are strings for
 *  functions and special constants (like _sin_ or _pi_), integer numbers,
 *  decimal numbers and special symbol characters like parentheses or the plus
 *  sign.
 *
 *  At this stage we are not concerned with their meaning, we only want to
 *  decide what the user's input is made of. We well then later decide if that
 *  input is a valid operator, and then finally of those operators constitute a
 *  valid syntax.
 *
 *  The last enum item is not an actual state, but it tells us how many states
 *  the state machine actually has.
 */
enum lexer_state{
	ST_START     , /**< Return after encountering whitespace or symbol. */
	ST_ERROR     , /**< State after encountering a format error.        */
	ST_ACCEPT    , /**< State for successful parsing.                   */
	ST_LETTER    , /**< Concatenating letters into words for functions. */
	ST_NUMBER    , /**< Gathering digits into a complete number.        */
	ST_DEC_PNT   , /**< Right after reading a decimal point.            */
	ST_DEC_NUM   , /**< After encountering a decimal point.             */
	ST_SYMBOL    , /**< State for non-alphanumeric characters.          */
	LEXER_STATES , /**< Useful constant, not an actual state.           */
};

/** Enum of possible input character types.
 *
 *  Every input character can be roughly categorized into one of the following
 *  character classes. We use this information to decide what state to switch
 *  the machine to next.
 */
enum char_class {
	CH_LETTER    , /**< Class for letter a - z and A - Z.      */
	CH_DIGIT     , /**< Class for digits 0 - 9.                */
	CH_DECIMAL   , /**< Class for the *full stop* character.   */
	CH_SYMBOL    , /**< Class for non-alphanumeric characters. */
	CH_SPACE     , /**< Class for whitespace characters.       */
	CH_UNKNOWN   , /**< Class for unknown characters.          */
	CHAR_CLASSES , /**< Useful constant, not an actual token.  */
};

/** Associativity of an operator
 *
 *  Most operator are left-associative, only functions and the _power_ operator
 *  are right-associative. The shunting-yard algorithm needs this information.
 */
enum operator_associativity {
	ASC_LEFT  , /**< Right-associative. */
	ASC_RIGHT , /**< Right-associative. */
};

/*---[ Structures ]-----------------------------------------------------------*/
typedef struct lexer {
	/** Parser to parse the nodes generated by this lexer. */
	struct parser *parser;

	/** Immutable pointer to the first character of the string to lex.
	 *
	 *  This is useful if we want to know where the read head is in relation to the
	 *  starting position, like when we want to know which character exactly the
	 *  lexer choked on. In that case we simply print `read_head -
	 *  string_to_parse`.
	 */
	const char *string_to_parse;

	/** Pointer to a char within the string to parse.
	 *
	 *  This pointer will be incremented each time we have successfully read a
	 *  character until we reach the end end of the string. This is analogous to
	 *  the reading head of a read-only Turing machine.
	 */
	const char *read_head;

	/** The current state of the state machine.
	 *
	 *  This variable keeps track of the current state of the state machine. It
	 *  only tracks the state we are currently in, not the state we came from.
	 */
	enum lexer_state current_state;

	/** The previous state of the state machine.
	 *
	 *  This variable keeps track of the previous state of the state machine. It is
	 *  the complement of #current_state.
	 */
	enum lexer_state previous_state;

	/** Number buffer for collecting numbers.
	 *
	 *  When we read a digit we cannot be sure that that digit is the entire
	 *  number. There could be other digits and even a decimal point following,
	 *  which would all form one larger number together. This variable is where we
	 *  process all those digits into one number until we are done. Then we pass
	 *  the result on.
	 */
	double number_buffer;

	/** Keeps track of the current power of ten.
	 *
	 *  Each time we read a digit the power of ten of that digit in the resulting
	 *  number increases. For integer numbers we can simply multiply the current
	 *  number buffer by ten and add the digit, so we don't need to keep track of
	 *  the power. However, for decimal numbers do need to know the current power.
	 *  The formula is:
	 *  @code
	 *      number_buffer += char_to_double(read_head) * power;
	 *      power *= 0.1;
	 *  @endcode
	 */
	double power;

	/** String buffer for collecting characters into a string.
	 *
	 *  Characters read by the machine are stored in this buffer until a non-letter
	 *  character is read. The buffer is initially filled with NUL characters until
	 *  it's needed, and after we are done we fill it with NUL characters again.
	 */
	char string_buf[STRING_BUFFER_LENGTH + 1]; // three characters + 1 for \0

	/** Pointer moving through the string buffer.
	 *
	 *  The string buffer stores the string, but this pointer tells us where in the
	 *  string we currently are. Each time we store a character int he buffer we
	 *  increment this pointer. Once done we set it back to the beginning of the
	 *  buffer.
	 */
	char *string_ptr;

	/** Character representing a single symbol.
	 *
	 *  If the parsing machine reads a symbol, which is a character that's neither
	 *  a digit nor a letter, but still a known character, it is a symbol. We store
	 *  it in this variable to retrieve if later.
	 */
	char symb;

	/** The previous node that was passed to the syntax tree builder.
	 *
	 *  This variable is used to differentiate the minus sign between the binary
	 *  subtraction and the unary negation. If the previous node is nothing or a
	 *  left parenthesis we have a negation, otherwise a subtraction.
	 */
	struct syntax_node *previous_node;
} Lexer;

/** Stack containing pointers to syntax nodes. */
struct syntax_node_stack {
	/** Store pointer to pointer of nodes, because the stack will be thrown away later. **/
	struct syntax_node **stack;

	size_t count;    /**< Number of items actually on the stack. */
	size_t capacity; /**< Number of items that can be stored.    */
};

/** Structure of a parser to build the function from tokens. */
typedef struct parser {
	/** Stack of root nodes for output.
	 *
	 *  By the time the parser is done there should be only one node remaining on
	 *  the stack: the root node of the function. All other nodes are its children.
	 *  If there are more nodes on the stack we have a syntax error.
	 */
	struct syntax_node_stack operand_stack;

	/** Stack of operator nodes waiting to be integrated into the function. */
	struct syntax_node_stack operator_stack;

	/** Previously parsed node.
	 *
	 *  We need to know what node we previously parsed in order to be able to
	 *  substitute the binary minus for a unary negate.
	 */
	SyntaxNode *previous_node;
} Parser;

/** Struct for the machine's transition information.
 *
 *  The struct tell us what action to perform when the machine is about the
 *  switch to the specified state. This is struct is useless if we don't know
 *  which state the machine is currently it. For instance, switching to the
 *  letter state after a number state will have a different effect than
 *  switching to the letter state while being already in the letter state.
 *
 *  This means we need some way to map the current state to a transition
 *  instruction; this is done in the #lexer_transition_table table.
 */
typedef struct transition_instruction {
	enum lexer_state next_state;
	int (*action)(Lexer *l);
} TransitionInstruction;

/*---[ Parser control functions ]---------------------------------------------*/

/** Parses a syntax node into the syntax tree.
 *
 *  This is the true heart of the parser. It implements the shunting-yard
 *  algorithm and is called when a node is passed to the parser.
 *
 *  @param p     Parser to parse the node.
 *  @param node  The syntax node that will be "digested" and parsed into the
 *               syntax tree.
 */
static int parse_node(Parser *p, SyntaxNode *node);

/** Pops a single operator off the operator stack.
 *
 *  This function will pop one operator off the stack and then pops as many
 *  operands form the operand stack as the arity of the operator is and adds
 *  them as children to the operator. The operator is then pushed onto the
 *  operand stack as the root of a new tree. This tree might later become and
 *  operand of another operator that got popped as well.
 *
 *  @param p  Parser to work with.
 */
static int pop_operator(Parser *p);

/*---[ Syntax node stack functions ]------------------------------------------*/

/** Push a new pointer onto the stack.
 *
 *  @param stack  The stack to push onto.
 *  @param node   Pointer to the node to push.
 */
static int syntax_node_stack_push(struct syntax_node_stack *stack, SyntaxNode *value);

/** Pop a pointer off the stack.
 *
 *  @param stack  Stack to pop from.
 *
 *  @return  Pointer to the node that has been popped off the stack.
 *
 *  Note that if the stack fails to shrink the old memory still remains valid.
 *  As such it is not necessary to handle the returned error code, it is
 *  optional. The capacity of the stack will remain untouched in that case.
 *  There is no error message printed either.
 */
static int syntax_node_stack_pop(struct syntax_node_stack *stack, SyntaxNode **value);

/*--[ control instructions for the machine ]----------------------------------*/

/** Creates a character class item based on the type of character read.
 *
 *  This function takes in a character and decides what type of character it
 *  is, i.e. a letter, a digit, a symbol, a decimal point or a whitespace.
 *  Depending on that it returns the appropriate class item.
 *
 *  @param character  The character being read.
 *
 *  @returns  Character class item that represents the type of the input
 *            character.
 */
static enum char_class digest_input_char(Lexer *l, const char *character);

/** Passes a syntax node over to the parser.
 *
 *  Certain lexer actions generate syntax nodes, these nodes must then be
 *  passed to the parser where the shunting-yard algorithm will construct the
 *  tree. This node also becomes the new previous node, which is sometimes used
 *  for reference.
 *
 *  @param node  The node to be passed to the parser.
 *
 *  @sa previous_node, syntax_tree_builder_parse_node
 */
static int pass_syntax_node(Lexer *l, Operator o, double n);

/*--[ Actions ]---------------------------------------------------------------*/

/** Lexer action that does nothing.
 *
 *  This action is only used when transitioning into the error state or the
 *  accepting state.
 */
static int no_act(Lexer *l);

/** Lexer action that Initialises the power counter for decimal numbers.
 *
 *  This action sets the power counter to 0.1 and is called when the number
 *  parsed is a decimal number.
 *
 *  @sa  power
 */
static int init_decimal(Lexer *l);

/** Lexer action that appends a digit to the number buffer.
 *
 *  This action multiplies the number buffer by 10 and adds the numeric value
 *  of the current character (a digit) to it. This has the same effect as
 *  appending a digit to an existing number.
 *
 *  @sa number_buffer
 */
static int append_digit(Lexer *l);

/** Lexer action that appends a decimal digit to the number buffer.
 *
 *  This action adds the numeric value of the current character multiplied by
 *  the current number power to the number buffer. Then it multiplies the power
 *  counter by 0.1 for the next digit. If the end of the buffer has already
 *  been reached a format error is thrown.
 *
 *  @sa string_buf, string_ptr
 */
static int append_decimal(Lexer *l);

/** Lexer action that appends a character to the string buffer.
 *
 *  This action appends the current character to the current position in the
 *  string buffer. It does so by inserting the character at the position the
 *  string pointer is pointing at and then incrementing the pointer.
 *
 *  @sa number_buffer, power
 */
static int append_char(Lexer *l);

/** Lexer action that passes a number node.
 *
 *  This action constructs a number node out of the number buffer, passes it to
 *  the syntax tree builder and then resets the number buffer.
 *
 *  @sa number_buffer, pass_syntax_node
 */
static int pass_number_node(Lexer *l);

/** Lexer action that passes a function node.
 *
 *  This action constructs a function node out of the string buffer, passes it
 *  to the syntax tree builder and then resets the string buffer and string
 *  pointer.
 *
 *  @sa string_buf, string_ptr, pass_syntax_node
 */
static int pass_function_node(Lexer *l);

/** Lexer action that passes a symbol node.
 *
 *  This action constructs a symbol node out of the current character and
 *  passes it to the syntax tree builder.
 *
 *  @sa char_to_operator, pass_syntax_node
 */
static int pass_symbol_node(Lexer *l);

/*---[ Helper functions ]-----------------------------------------------------*/

/** Checks if an operator token represents a function.
 *
 *  @param t  The token to check.
 *
 *  @return  Returns 1 if the token is a function, 0 otherwise.
 */
static int token_is_function(enum operator_type t);

static int token_is_operator(enum operator_type t);
static int token_is_constant(enum operator_type t);

static int token_is_variable(enum operator_type t);
static enum operator_associativity op_assoc(enum operator_type t);

/*===[ Array and tables ]=====================================================*/

/** Array of transition instructions, structured like a table.
 *
 *  The first coordinate corresponds to the current state, the second one to
 *  the type of symbol that's read.
 */
static struct transition_instruction lexer_transition_table[LEXER_STATES][CHAR_CLASSES] = {
	[ST_START] = {
		[ CH_LETTER  ] = { .next_state = ST_LETTER  , .action = append_char        },
		[ CH_DIGIT   ] = { .next_state = ST_NUMBER  , .action = append_digit       },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_SYMBOL  , .action = pass_symbol_node   },
		[ CH_SPACE   ] = { .next_state = ST_START   , .action = no_act             },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act             },
	},
	[ST_ERROR ] = {
		[ CH_LETTER  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DIGIT   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SPACE   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act             },
	},
	[ST_ACCEPT] = {
		[ CH_LETTER  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DIGIT   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SPACE   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act             },
	},
	[ST_LETTER] = {
		[ CH_LETTER  ] = { .next_state = ST_LETTER  , .action = append_char        },
		[ CH_DIGIT   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_SYMBOL  , .action = pass_function_node },
		[ CH_SPACE   ] = { .next_state = ST_START   , .action = pass_function_node },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act             },
	},
	[ST_NUMBER] = {
		[ CH_LETTER  ] = { .next_state = ST_LETTER  , .action = pass_number_node   },
		[ CH_DIGIT   ] = { .next_state = ST_NUMBER  , .action = append_digit       },
		[ CH_DECIMAL ] = { .next_state = ST_DEC_PNT , .action = init_decimal       },
		[ CH_SYMBOL  ] = { .next_state = ST_SYMBOL  , .action = pass_number_node   },
		[ CH_SPACE   ] = { .next_state = ST_START   , .action = pass_number_node   },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act}
	},
	[ST_DEC_PNT] = {
		[ CH_LETTER  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_DIGIT   ] = { .next_state = ST_DEC_NUM , .action = append_decimal     },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SPACE   ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act}
	},
	[ST_DEC_NUM] = {
		[ CH_LETTER  ] = { .next_state = ST_LETTER  , .action = pass_number_node   },
		[ CH_DIGIT   ] = { .next_state = ST_DEC_NUM , .action = append_decimal     },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_SYMBOL  , .action = pass_number_node   },
		[ CH_SPACE   ] = { .next_state = ST_START   , .action = pass_number_node   },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act}
	},
	[ST_SYMBOL] = {
		[ CH_LETTER  ] = { .next_state = ST_LETTER  , .action = append_char        },
		[ CH_DIGIT   ] = { .next_state = ST_NUMBER  , .action = append_digit       },
		[ CH_DECIMAL ] = { .next_state = ST_ERROR   , .action = no_act             },
		[ CH_SYMBOL  ] = { .next_state = ST_SYMBOL  , .action = pass_symbol_node   },
		[ CH_SPACE   ] = { .next_state = ST_START   , .action = no_act             },
		[ CH_UNKNOWN ] = { .next_state = ST_ERROR   , .action = no_act             },
	},
};

/*===[ IMPLEMENTATIONS ]======================================================*/

int compiler_frontend(const char *const source, SyntaxNode **tree) {
	assert(*tree == NULL); /* Must be NULL. */

	int error = 0; /* No error */
	Lexer  *l; /* Lexer used by the backend.  */
	Parser *p; /* Parser used by the backend. */

	/* Set up the lexer and parser */
	l = malloc(sizeof(Lexer));
	if (!l) {
		fprintf(stderr, "Memory error: could not allocate backend lexer.\n");
		error = 1;
		goto end;
	}

	/* The lexer's parser */ {
		l->parser = malloc(sizeof(struct parser));
		if (!l->parser) {
			error = 1;
			fprintf(stderr, "Memory error: could not allocate backend parser.\n");
			free(l);
			goto end;
		}

		l->parser->operand_stack = (struct syntax_node_stack){
			.stack = malloc(2 * sizeof(SyntaxNode *)),
			.count = 0,
			.capacity = 2
		};

		l->parser->operator_stack = (struct syntax_node_stack){
			.stack = malloc(2 * sizeof(SyntaxNode *)),
			.count = 0,
			.capacity = 2
		};

		if (!l->parser->operand_stack.stack || !l->parser->operator_stack.stack) {
			fprintf(stderr, "Memory error: could not allocate parser stacks.\n");
			free(l->parser);
			l->parser = NULL;
			free(l);
			error = 1;
			goto end;
		}
	}
	p = l->parser;

	/* Lexer fields */

	l->previous_node = NULL;
	l->read_head = l->string_to_parse = source;

	l->current_state = lexer_transition_table[ST_START][digest_input_char(l, l->read_head)].next_state;
	l->previous_state = ST_START;

	l->string_buf[STRING_BUFFER_LENGTH] = '\0';
	l->string_ptr = l->string_buf; /* set the buffer pointer to the buffer's head */

	/* set up the number buffer for collecting digits into numbers */
	l->number_buffer = 0.0;
	l->power = 0.1;

	lexer_transition_table[l->current_state][digest_input_char(l, l->read_head)].action(l);
	++(l->read_head);

	/* This is the actual lexing process */
	while (l->current_state != ST_ERROR) {
		if (*(l->read_head) == '\0') { /* reached the end of the string without problems */
			/* perform the action of the previous state before shutting down the machine */
			error = lexer_transition_table[l->current_state][CH_SPACE].action(l);
			if (error) {
				goto cleanup;
			}
			l->current_state = ST_ACCEPT;
			break; /* Break out of the loop */
		}
		/* Transition state */
		enum char_class chr;

		/* Get the next state */
		l->previous_state  = l->current_state;
		/* What type of character did we read now? */
		chr = digest_input_char(l, l->read_head);
		/* Don't handle unknown characters, the lexer will transition to the
 		 * error state gracefully. */

		/* Use that information to transition into the new state */
		l->current_state = lexer_transition_table[l->current_state][chr].next_state;
		/* Perform the action of the previous state */
		lexer_transition_table[l->previous_state][chr].action(l);

		++l->read_head;
	}

	/* The lexing is done now,  destroy the lexer. */

	/* If an exception occurred */
	if (l->current_state == ST_ERROR) {
		/* This is an exception, so the exit code should not be the same as for an error */
		fprintf(stderr, "Formating error while parsing function.");
		goto cleanup;
	}

	/* Wrap up the parser first */

	/* pop all the operators from the operator stack onto the operand stack */
	while (p->operator_stack.count > 0) {
		/* By this point there should be no opening parentheses      *
		 * on the stack anymore. If there are we have a syntax error */
		if(p->operator_stack.stack[p->operator_stack.count-1]->operator_value == OP_LEFT_BRACE){
			fprintf(stderr, "Syntax error: no matching closing parenthesis found.\n");
			error = 1;
			goto cleanup;
		}
		pop_operator(p);
	}

	if (p->operand_stack.count != 1) {
		fprintf(stderr, "Syntax Error: More operands than operators");
		error = 1;
		goto cleanup;
	}

	/* save the syntax tree of the function */
	syntax_node_stack_pop(&p->operand_stack, tree);

/* This is where all the allocated memory is freed again. */
cleanup:
	/* purge and destroy the operator stack */
	for (int i = 0; i < p->operator_stack.count; ++i) {
		/* If there is anything left on the operator stack we have had an error. */
		error = error ? error : 1;
		syntax_node_destroy(p->operator_stack.stack[i]);
	}
	free(p->operator_stack.stack);

	/* On success the last tree will have been popped already */
	for (int i = 0; i < p->operand_stack.count; ++i) {
		error = error ? error : 1;
		syntax_node_destroy(p->operand_stack.stack[i]);
	}
	free(p->operand_stack.stack);

	free(p);
	p = l->parser = NULL;
	free(l);
	l = NULL;

end:
	return error;
}

/*---[ Parser implementation ]------------------------------------------------*/

static int parse_node(struct parser *p, struct syntax_node *node) {
	int error = 0; /* No error */
	Operator   token = node->operator_value;
	p->previous_node = node;

	/* Numbers, constants and variables always on the operand stack. */
	if (token == OP_NUMBER || token_is_constant(token) || token_is_variable(token)) {
		error = syntax_node_stack_push(&p->operand_stack, node);
		if (error) {
			fprintf(stderr, "Parser Error: Could not push operand to stack.\n");
		}
		return error;
	}

	/* Functions always go on the operator stack. */
	if (token_is_function(token)) {
		error = syntax_node_stack_push(&p->operator_stack, node);
		if (error) {
			fprintf(stderr, "Parser Error: Could not push operator to stack.\n");
		}
		return error;
	}

	/* If the token is an operator. */
	if (token_is_operator(token)) {
		/* As long as there is an operator on the stack... */
		while (p->operator_stack.count > 0) {
			/* Operator on top of the operator stack. */
			#define STACK_TOP p->operator_stack.stack[p->operator_stack.count-1]->operator_value
			/* Precedences, and asserting they are not 0 */
			unsigned int precedence_current = operator_precedence[token    ];
			unsigned int precedence_top     = operator_precedence[STACK_TOP];
			assert(precedence_current != 0);
			assert(precedence_top     != 0);


			#define CONDITION_A ( \
				op_assoc(token) == ASC_LEFT \
				&& \
				precedence_current \
				<= \
				precedence_top \
				)

			#define CONDITION_B ( \
				op_assoc(token) == ASC_RIGHT \
				&& \
				precedence_current \
				< \
				precedence_top \
				)
			if (CONDITION_A || CONDITION_B) {
				error = pop_operator(p);
				if (error) {
					fprintf(stderr, "Parser error: Could not pop operator from stack.\n");
					return error;
				}
			} else {
				break;
			}
			#undef CONDITION_A
			#undef CONDITION_B
			#undef TOP_OP
		}
		error = syntax_node_stack_push(&p->operator_stack, node);
		if (error) {
			fprintf(stderr, "Parser Error: Could not push operator to stack.\n");
		}
		return error;
	}

	/* If the token is a left parenthesis push it onto the operator stack */
	if (token == OP_LEFT_BRACE) {
		syntax_node_stack_push(&p->operator_stack, node);
		if (error) {
			fprintf(stderr, "Parser Error: Could not push operator to stack.\n");
		}
		return error;
	}

	/* If the token is a right parenthesis */
	if (token == OP_RIGHT_BRACE) {
		while (p->operator_stack.count > 0) {
			/* If we find a matching closing brace... */
			if (p->operator_stack.stack[p->operator_stack.count-1]->operator_value == OP_LEFT_BRACE) {
				/* Free it and throw it away */
				free(p->operator_stack.stack[--p->operator_stack.count]);

				/* If the top of the operator stack is a function pop it as well. */
				#define STACK_TOP p->operator_stack.stack[p->operator_stack.count-1]->operator_value
				if (p->operator_stack.count > 0 && token_is_function(STACK_TOP)) {
					error = pop_operator(p);
						if (error) {
							fprintf(stderr, "Parser error: Could not pop operator from stack.\n");
						}
				}
				#undef TOP_OP
				/* we have our closing brace, so break out of the function */
				return error;
			}
			/* Otherwise pop the next operator from the stack */
			pop_operator(p);
		}

		// If we made it to here it means we have emptied the stack
		// without finding the closing brace. That's a syntax error.
		fprintf(stderr, "Syntax error: no matching opening parenthesis found.\n");
		return 1;
	}

	/* If the token is none of these types we have an undefined type */
	fprintf(stderr, "Syntax error: unknown type of token %i.\n", token);
	return 1;
}

static int pop_operator(Parser *p) {
	int error = 0; /* No error */
	struct syntax_node *op;

	/* pop operators off the operator stack, onto the output stack */
	syntax_node_stack_pop(&p->operator_stack, &op);

	/* pop the right amount of operands off the output stack... */
	for (int i = op->arity; i > 0; --i) {
		if (p->operand_stack.count == 0) {
			fprintf(stderr, "Syntax error: operator has too few operands.\n");
			error = 1;
			goto end;
		}
		/* ...and set them as operands to this node (back to front). */
		syntax_node_stack_pop(&p->operand_stack, op->operand + i - 1);
	}

	/* push this operator node to the output stack */
	error = syntax_node_stack_push(&p->operand_stack, op);
	if (error) {
		fprintf(stderr, "Parser error: Could not push operator to stack after popping.\n");
	}

end:
	return error;
}

/*---[ Syntax Node Stack implementation ]-------------------------------------*/

static int syntax_node_stack_push(struct syntax_node_stack *stack, SyntaxNode *value ) {
	assert(0 <= stack->count && stack->count <= stack->capacity);

	int error = 0; /* No error. */

	// Stack will grow if it is full (top == capacity - 1)
	//
	// Example: capacity = 4, top = 3
	//          => Stack full; after increment: top == capacity
	if(stack->count == stack->capacity) {
		SyntaxNode **new_stack = realloc(stack->stack, 2 * stack->count * sizeof(SyntaxNode*));
		if (!new_stack) {
			fprintf(stderr, "Memory error: Stack overflow, could not grow stack.\n");
			error = 1;
			goto end;
		}
		stack->stack = new_stack;
		stack->capacity = 2 * stack->count;
	}
	stack->stack[stack->count++] = value;

end:
	assert(0 < stack->count && stack->count <= stack->capacity);
	return error;
}

static int syntax_node_stack_pop(struct syntax_node_stack *stack, SyntaxNode **value) {
	assert(0 < stack->count && stack->count <= stack->capacity);

	int error = 0; /* No error. */
	*value = stack->stack[--stack->count];

	// Stack will shrink by half if it is only one quarter full, but avoid a
	// stack with no capacity.
	//
	// Example: capacity = 8, count = 2
	//          => 4*count = 4*2 = 8 = capacity
	//          => capacity shrunk to 2*2 = 4
	if (4 * stack->count <= stack->capacity && stack->count > 0) {
		SyntaxNode **new_stack = realloc(stack->stack, (2 * stack->count) * sizeof(SyntaxNode *));
		if (!new_stack) {error = 1; goto end;}
		stack->stack = new_stack;
		stack->capacity = 2 * stack->count;
	}

end:
	assert(0 <= stack->count && stack->count < stack->capacity);
	return error;
}

/*---[ Action implementation ]------------------------------------------------*/

static int no_act(Lexer *l) {return 0;}

static int init_decimal(Lexer *l) {
	l->power = 0.1;
	return 0;
}

static int append_digit(Lexer *l) {
	double number = (double) (*l->read_head - '0');
	l->number_buffer = l->number_buffer * 10.0 + number;
	return 0;
}

static int append_decimal(Lexer *l) {
	double number = (double) (*l->read_head - '0');
	l->number_buffer += number * l->power;
	l->power *= 0.1;
	return 0;
}

static int append_char(Lexer *l) {
	int error = 0; /* No error. */

	// we have reached the end of the string buffer, reading more is an error
	if (l->string_ptr - &(l->string_buf[0]) >= STRING_BUFFER_LENGTH) {
		error = 1;
		l->current_state = ST_ERROR;
		fprintf(stderr,
		        "Error while parsing: string buffer full, currently %s, trying to append %c.\n"
		        "The maximum length of a legal function string is %i.\n",
		        l->string_buf, *l->string_ptr, STRING_BUFFER_LENGTH
		);
		goto end;
	}

	*l->string_ptr = *l->read_head;
	++l->string_ptr;

end:
	return error;
}

static int pass_number_node(Lexer *l) {
	int error = 0; /* No error */

	/* pass the number to the tree-builder */
	error = pass_syntax_node(l, OP_NUMBER, l->number_buffer);
	if (error) {goto end;}

	l->number_buffer = 0.0;
	/* if the number is followed by a letter... */
	if (l->current_state == ST_LETTER) {
		/* ... also pass a TIMES */
		error = pass_syntax_node(l, OP_TIMES, 0);
		if (error) {goto end;}

		/* reset the string buffer */
		for (int i = 0; i < STRING_BUFFER_LENGTH; ++i) {
			(l->string_buf)[i] = '\0';
		}
		l->string_ptr = &(l->string_buf[0]);
		append_char(l);
	}
	l->number_buffer = 0.0;
	l->power = 0.1;

	if (l->current_state == ST_SYMBOL) {
		error = pass_symbol_node(l);
	}

end:
	return error;
}

static int pass_function_node(Lexer *l) {
	int error = 0; /* No error. */

	/* terminate the string buffer with \0 */
	*l->string_ptr = '\0';
	Operator o = string_to_operator(l->string_buf);

	if (!o) {
		fprintf(stderr,
		        "Format error: Unknown function %s.\n",
		        l->string_buf
		);
		error = 1;
		goto end;
	}

	/* pick the right function operator and pass it */
	if ((error = pass_syntax_node(l, o, 0))) {
		goto end;
	}

	l->string_ptr = &l->string_buf[0]; /* set pointer back to beginning of the string */
	for (int i = 0; i < STRING_BUFFER_LENGTH; ++i) { /* clean up string buffer */
		l->string_buf[i] = '\0';
	}

	if (l->current_state == ST_SYMBOL) {
		if ((error = pass_symbol_node(l))) {
			goto end;
		}
	}

end:
	return error;
}

static int pass_symbol_node(Lexer *l) {
	int error = 0; /* No error. */
	Operator o; /* Current operator  */
	Operator p; /* Previous operator */

	/* Pick the symbol and pass it */
	o = char_to_operator(&l->symb);
	/* If there is no previous operator it is "unknown" */
	p = l->previous_node == NULL ? OP_UNKNOWN : l->previous_node->operator_value;

	if (o == OP_UNKNOWN) {
		fprintf(stderr, "Format error: unknown symbol %c.\n", l->symb);
		error = 1;
		goto end;
	}

	// substitute OP_MINUS with OP_NEGATE if necessary; a unary minus is
	// allowed either at the start of the expression or following an opening
	// brace.
	if (o == OP_MINUS && (!p || p == OP_LEFT_BRACE)) {
		o = OP_NEGATE;
	}
	error = pass_syntax_node(l, o, 0);

end:
	return error;
}

static int pass_syntax_node(Lexer *l, Operator o, double n) {
	int error = 0; /* No error. */
	SyntaxNode *node = syntax_node_construct(o, n);

	if (!node) {
		fprintf(stderr,
		        "Compiler error: could not pass not to parser.\n"
		);
		error = 1;
		goto end;
	}

	/* implicit OP_TIMES */
	if (l->previous_node) {
		Operator p = l->previous_node->operator_value;
		/* preceding an opening brace after a nullary token */
		if (o == OP_LEFT_BRACE && l->previous_node->arity == 0) {
			error |= pass_syntax_node(l, OP_TIMES, 0);
		}

		// succeeding a closing brace before a unary or nullary token
		if (p == OP_RIGHT_BRACE && node->arity < 2) {
			error |= pass_syntax_node(l, OP_TIMES, 0);
		}
		// This is not quite right, even an n-ary token following a closing
		// brace can prompt and implicit *times*, as long as it's a prefix
		// operator, like a function. We don't have those though.

		if (error) {
			goto end;
		}
	}
	l->previous_node = node;
	parse_node(l->parser, node);

end:
	return error;
}

/*---[ Helper implementation ]------------------------------------------------*/

static int token_is_function(enum operator_type t) {
	return (t == OP_EXP || t == OP_LN || t == OP_SIN || t == OP_COS || t == OP_TAN) ? 1 : 0;
}

static int token_is_operator(enum operator_type t) {
	return (t == OP_NEGATE || t == OP_PLUS || t == OP_MINUS || t == OP_TIMES || t == OP_DIVIDE || t == OP_POWER) ? 1 : 0;
}

static int token_is_constant(enum operator_type t) {
	return (t == OP_PI || t == OP_E) ? 1 : 0;
}

static int token_is_variable(enum operator_type t) {
	return t == OP_X_VAR ? 1 : 0;
}

enum operator_associativity op_assoc(enum operator_type t) {
	return (t == OP_POWER || t == OP_NEGATE|| token_is_function(t)) ? ASC_RIGHT : ASC_LEFT;
}

enum char_class digest_input_char(Lexer *l, const char *character) {
	if (isalpha(*character)) {
		return CH_LETTER;
	}
	if (isdigit(*character)) {
		return CH_DIGIT;
	}
	if (*character == '+' || *character == '-' || *character == '*' || *character == '/' || *character == '^'
		|| *character == '(' || *character == ')'
		|| *character == '[' || *character == ']') {
		l->symb = *character;
		return CH_SYMBOL ;
	}
	if (*character == '.') {
		return CH_DECIMAL;
	}
	if (isspace(*character)) {
		return CH_SPACE;
	}

	fprintf(
		stderr, "Format error: character \'%c\' from the input formula does not"
		"correspond to any known symbol or function. Error noticed at position %li .\n",
		*character, l->read_head - l->string_to_parse
	);

	return CH_UNKNOWN;
}

